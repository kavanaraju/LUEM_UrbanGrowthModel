---
# CPLN 6750 – Phoenix Urban Growth Forecast, 2031

**Authors:** Sravya Dandamudi & Kavana Raju
**Date:** ** 5/10/2025 **

---

```{r setup, include=FALSE}
# -----------------------------------
# 0. SETUP
# -----------------------------------
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 5
)
# Load packages
pkgs <- c(
  "tidyverse","sf","raster","terra","exactextractr",
  "tidycensus","tigris","FNN","caret","yardstick","plotROC",
  "kableExtra","mapview","FedData"
)
lapply(pkgs, function(p) if(!requireNamespace(p,quietly=TRUE)) install.packages(p))
lapply(pkgs, library, character.only=TRUE)

# Custom helper functions (from example)
quintileBreaks <- function(df, variable) {
  as.character(quantile(df[[variable]], c(.01,.2,.4,.6,.8), na.rm=TRUE))
}
xyC <- function(aPolygonSF) {
  as.data.frame(cbind(
    x=st_coordinates(st_centroid(aPolygonSF))[,1],
    y=st_coordinates(st_centroid(aPolygonSF))[,2]
  ))
}
rast <- function(inRaster) {
  df <- data.frame(xyFromCell(inRaster, 1:ncell(inRaster)),
                   value=getValues(inRaster))
  colnames(df) <- c('x','y','value')
  df}

nn_function <- function(measureFrom, measureTo, k) {
  mf <- as.matrix(measureFrom)
  mt <- as.matrix(measureTo)
  dists <- get.knnx(mt, mf, k)$nn.dist
  rowMeans(dists)}

aggregateRaster <- function(rasterList, fishnet) {
  # Initialize result with the original fishnet
  result <- fishnet
  for(r in rasterList) {
    nm <- names(r)
    # Convert raster cells == 1 to points (use the named column)
    pts <- rasterToPoints(r) %>%
      as.data.frame() %>%
      dplyr::filter(.data[[nm]] == 1) %>%
      st_as_sf(coords = c('x','y'), crs = st_crs(fishnet))
    # Count points per fishnet cell
    agg <- aggregate(pts, fishnet, FUN = length)
    # Create binary indicator: 1 if any point falls inside
    result[[nm]] <- ifelse(is.na(agg$layer) | agg$layer == 0, 0, 1)
  }
  return(result)
}
```

# 1. Introduction

This report builds a spatial logistic regression model of urban development in the Phoenix–Mesa–Scottsdale MSA, using land cover change from 2011 to 2021 as training data. We then forecast development to 2031 under a scenario where a new transportation corridor is introduced. Finally, we assess where sensitive lands (flood zones, protected areas) are at risk and propose planning recommendations.

# 2. Workflow Overview

1. Import and preprocess land cover rasters (2011, 2021)  
2. Reclassify to developed/undeveloped and derive change raster  
3. Build a fishnet grid and aggregate raster and vector features to each cell  
4. Engineer predictors: distance to roads, spatial lag, census variables, slope  
5. Train logistic regression model (2011→2021) and validate  
6. Forecast to 2031 using 2021 inputs + new infrastructure scenario  
7. Assess impacts on sensitive lands  
8. Provide three key recommendations

# 3. Study Area Boundary

```{r load-boundary}
# Load Boundary for Phoem
phx_msa <- st_read("data/Phoenix_MSA/Phoenix_MSA.shp", quiet=TRUE) %>%
  st_transform(26912)  # NAD83 / Arizona Central
```

# 4. Load Land Cover Data (NLCD)

```{r load-nlcd}
# Load NLCDrasters
lc_2011 <- raster("data/Annual_NLCD_LndCov_2011_CU_C1V0.tif")  
lc_2021 <- raster("data/Annual_NLCD_LndCov_2021_CU_C1V0.tif")

# Transform the MSA boundary to match the raster CRS
phx_msa_r <- st_transform(phx_msa, crs(lc_2011))

# Crop and mask the country-wide rasters to the Phoenix MSA boundary
lc_2011 <- crop(lc_2011, phx_msa_r)
lc_2011 <- mask(lc_2011, phx_msa_r)

lc_2021 <- crop(lc_2021, phx_msa_r)
lc_2021 <- mask(lc_2021, phx_msa_r)

# Reproject masked rasters back to study CRS
lc_2011 <- projectRaster(lc_2011, crs = 26912)
lc_2021 <- projectRaster(lc_2021, crs = 26912)
```
```{r save-lc}
writeRaster(
  x         = lc_2011,
  filename  = "data/LC_2011_PhoenixMSA",
  filetype  = "GTiff",
  overwrite = TRUE)

writeRaster(
  x         = lc_2021,
  filename  = "data/LC_2021_PhoenixMSA",
  filetype  = "GTiff",
  overwrite = TRUE)
```

# 5. Detecting Land Cover Conversion

```{r detect-change}
# Resample to 300m (To capture finer details as we're analyzing the extension - TOD)
lc1_rs <- aggregate(lc_2011, fact=10, fun="modal")
lc2_rs <- aggregate(lc_2021, fact=10, fun="modal")

# Align origins, resolution, and extent
lc2_rs <- resample(lc2_rs, lc1_rs, method="ngb")

# Reclassify developed classes (NLCD 21–24)
rc <- matrix(c(0,12,0, 12,24,1, 24,Inf,0), ncol=3, byrow=TRUE)
dev1 <- reclassify(lc1_rs, rc)
dev2 <- reclassify(lc2_rs, rc)

# Map algebra: 1 = change from undeveloped to developed
# dev1=0 & dev2=1 => converted; dev1=1 & dev2=0 => unlikely here
dev_change <- dev1 + dev2
# Keep only converted cells
dev_change[dev_change != 1] <- NA
```

# 6. Creating the Fishnet Grid

```{r fishnet}
grid_res <- res(lc1_rs)[1] #cell size



fishnet <- st_make_grid(phx_msa, cellsize=grid_res, square=TRUE) %>%
  st_sf() %>% st_intersection(phx_msa) %>%
  mutate(cell_id = row_number())
```

# 7. Join Raster Change to Fishnet

```{r join-change}
# Convert the change raster to points
pts_change <- rasterToPoints(dev_change) %>% 
  as.data.frame() %>% 
  st_as_sf(coords = c('x','y'), crs = st_crs(fishnet))

# Aggregate change points to fishnet grid
fishnet <- aggregate(pts_change, fishnet, FUN = sum) %>%
  mutate(development_change = factor(ifelse(layer > 0, 1, 0))) %>%
  dplyr::select(-layer)
```

# 8. Aggregating Land Cover Categories

```{r lc-categories}
# Define binary reclassified rasters for 2011 (t1)
dev1      <- lc1_rs %in% c(21:24);    names(dev1)      <- "dev1"
forest1   <- lc1_rs %in% c(41:43);    names(forest1)   <- "forest1"
farm1     <- lc1_rs %in% c(81:82);    names(farm1)     <- "farm1"
wet1      <- lc1_rs %in% c(90,95);    names(wet1)      <- "wet1"
oth1      <- lc1_rs %in% c(31,52,71); names(oth1)      <- "oth1"
water1    <- lc1_rs == 11;            names(water1)    <- "water1"

# Aggregate all t1 categories into fishnet
rasters1  <- list(dev1, forest1, farm1, wet1, oth1, water1)
fishnet_lc1 <- aggregateRaster(rasters1, fishnet)

# Define binary reclassified rasters for 2021 (t2)
dev2      <- lc2_rs %in% c(21:24);    names(dev2)      <- "dev2"
forest2   <- lc2_rs %in% c(41:43);    names(forest2)   <- "forest2"
farm2     <- lc2_rs %in% c(81:82);    names(farm2)     <- "farm2"
wet2      <- lc2_rs %in% c(90,95);    names(wet2)      <- "wet2"
oth2      <- lc2_rs %in% c(31,52,71); names(oth2)      <- "oth2"
water2    <- lc2_rs == 11;            names(water2)    <- "water2"

# Aggregate all t2 categories into fishnet
rasters2  <- list(dev2, forest2, farm2, wet2, oth2, water2)
fishnet_lc2 <- aggregateRaster(rasters2, fishnet)
```

# 9. Population & Socioeconomic Data via tidycensus

```{r census}
census_api_key("52f0462d8b4e1e19ee64b25a3196677c5e32e660", install=FALSE)

# Variables: total population, median income, housing units
tidy_vars <- c(pop = "B01003_001E",
               income = "B19013_001E",
               housing = "B25001_001E")

# Specify counties for Phoenix MSA
counties <- c("Maricopa", "Pinal")

# Download 2011 ACS (wide format) and rename estimate columns
acs11 <- get_acs(
  geography = "tract",
  variables = tidy_vars,
  year = 2011,
  state = "AZ",
  county = counties,
  geometry = TRUE,
  output = "wide"
) %>%
  st_transform(st_crs(fishnet)) %>%
  rename(
    pop11 = pop,
    inc11 = income,
    house11 = housing
  ) %>%
  dplyr::select(GEOID, pop11, inc11, house11, geometry)

# Download 2021 ACS (wide format) and rename estimate columns
acs21 <- get_acs(
  geography = "tract",
  variables = tidy_vars,
  year = 2021,
  state = "AZ",
  county = counties,
  geometry = TRUE,
  output = "wide"
) %>%
  st_transform(st_crs(fishnet)) %>%
  rename(
    pop21 = pop,
    inc21 = income,
    house21 = housing
  ) %>%
  dplyr::select(GEOID, pop21, inc21, house21, geometry)

# Areal-weighted interpolation onto fishnet
fishnet_pop11 <- st_interpolate_aw(
  acs11[c("pop11", "inc11", "house11")],
  fishnet,
  extensive = TRUE
)
fishnet_pop21 <- st_interpolate_aw(
  acs21[c("pop21", "inc21", "house21")],
  fishnet,
  extensive = TRUE
)
```

# 10. Transportation & Infrastructure Features

```{r transport}
# Load existing light rail network
existing_lr <- st_read("data/LightRail_Existing/LightRail_Existing.shp")

existing_lr <- st_transform(existing_lr, st_crs(fishnet))

# Compute distance from each cell centroid to nearest existing light rail line
centroids <- st_centroid(fishnet)
fishnet$dist_lr_existing <- as.numeric(
  st_distance(centroids, st_union(existing_lr)))

# Proposed extension
new_lr <- st_read("data/LightRail_Extension/LightRail_Extension.shp")

new_lr <- st_transform(new_lr, st_crs(fishnet))

fishnet$dist_new <- as.numeric(st_distance(centroids, new_lr))
```

# 11. Spatial Lag of Development

```{r spatial-lag}
# Compute centroids once
centroids <- st_centroid(fishnet)
# Matrix of fishnet centroid coordinates
grid_xy <- st_coordinates(centroids)

# Extract fishnet_lc layers: dev1 and dev2 should already be numeric 0/1 columns
# No need to re-mutate dev1/dev2

# Points of converted cells in t1 and t2
t1_points <- fishnet_lc1 %>%
  filter(dev1 == 1) %>%        # dev1 is numeric vector
  st_centroid() %>%
  st_coordinates()
t2_points <- fishnet_lc2 %>%
  filter(dev2 == 1) %>%
  st_centroid() %>%
  st_coordinates()

# Compute spatial lag: average distance to 2 nearest developed cells
grid_lag1 <- nn_function(grid_xy, t1_points, k = 2)
grid_lag2 <- nn_function(grid_xy, t2_points, k = 2)

# Attach lag variables back to fishnet
fishnet <- fishnet %>%
  mutate(
    lagDev1 = grid_lag1,
    lagDev2 = grid_lag2
  )
```

# 12. County Fixed Effects

```{r county-fe}
cts <- counties(state="AZ", cb=TRUE) %>% st_transform(st_crs(fishnet)) %>%
  filter(NAME %in% c("Maricopa","Pinal"))
fishnet <- fishnet %>% st_join(cts["NAME"]) %>% rename(county=NAME)
```

# 13. Compile Modeling Data Sets

```{r compile}
# t1 data
dat11 <- bind_cols(
  st_drop_geometry(fishnet),
  st_drop_geometry(fishnet_lc1),
  st_drop_geometry(select(fishnet, dist_hwy, dist_new, lagDev1)),
  st_drop_geometry(fishnet_pop11)
) %>%
  select(cell_id, development_change, everything()) %>%
  filter(water1==0)
# rename t1 vars by dropping suffixes

# t2 data (forecast)
dat21 <- bind_cols(
  st_drop_geometry(fishnet),
  st_drop_geometry(fishnet_lc2),
  st_drop_geometry(select(fishnet, dist_hwy, dist_new, lagDev2)),
  st_drop_geometry(fishnet_pop21)
) %>% filter(water2==0)
```

# 14. Model Training & Validation

```{r modeling}
set.seed(1234)
idx <- createDataPartition(dat11$development_change, p=.7, list=FALSE)
train <- dat11[idx,]; test <- dat11[-idx,]
# Fit logit\model <- glm(development_change~dist_hwy+dist_new+pop11+lagDev1+inc11+housing11+county,
             data=train, family=binomial)
summary(model)
# ROC
probs <- predict(model, test, type="response")
ggplot(data.frame(obs=test$development_change, pred=probs),
       aes(d=as.numeric(obs), m=pred)) + geom_roc() + theme_minimal()
auc(roc(test$development_change, probs))
# Confusion
thr <- 0.1
pred_class <- factor(ifelse(probs>thr,1,0))
confusionMatrix(pred_class, factor(test$development_change), positive="1")
```

# 15. Forecast to 2031 & Impact Assessment

```{r forecast}
# Predict
dat21$prob31 <- predict(model, dat21, type="response")
dat21$pred31 <- factor(ifelse(dat21$prob31>thr,1,0))
forecast_sf <- left_join(fishnet, dat21, by="cell_id")
# Sensitive overlays
flood <- st_read("data/flood/fema_flood.shp") %>% st_transform(st_crs(fishnet))
prot  <- st_read("data/padus/padus_az.shp") %>% st_transform(st_crs(fishnet))
forecast_sf$flood_risk <- lengths(st_intersects(forecast_sf, flood))>0
forecast_sf$prot_risk  <- lengths(st_intersects(forecast_sf, prot))>0
# Summary
risk_sum <- forecast_sf %>%
  filter(pred31==1) %>%
  summarize(
    pct_flood=sum(flood_risk)/n()*100,
    pct_prot=sum(prot_risk)/n()*100
  )
kable(risk_sum)
# Map
ggplot(forecast_sf) +
  geom_sf(aes(fill=pred31), color=NA) +
  geom_sf(data=phx_msa, fill=NA) +
  labs(title="Projected 2031 Development") +
  theme_void()
```

# Recommendations

1. Strengthen floodplain regulations where > `r round(risk_sum$pct_flood,1)`% expansion occurs in flood zones.  
2. Establish green buffers around protected lands given ~`r round(risk_sum$pct_prot,1)`% overlap.  
3. Incentivize infill and higher density within 0.5 mi of the new corridor to curb leapfrog sprawl.

---

<small>Adapted from Houston Urban Growth Modeling example (Fichman et al.).</small>
